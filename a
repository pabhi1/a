


############################## FCFS #####################################################
import java.util.Scanner; class Fcfs {
    public static void main(String args[]){ int bst[],process[],wt[],tat[],i,j,n,total=0,pos,temp; 
        float wait_avg, TAT_avg; 
        Scanner s = new Scanner(System.in); 
        System.out.print("Enter number of process: "); n = s.nextInt(); 
        process = new int[n]; bst = new int[n]; wt = new int[n]; tat = new int[n]; 
        System.out.println("\nEnter CPU time:");
        for(i=0;i<n;i++)
        {
            System.out.print("\nProcess["+(i+1)+"]: ");
            bst[i] = s.nextInt();;
            process[i]=i+1; //Process Number
        }
        System.out.println("\t\t\t**********FCFS Scheduling*********");
        //First process has 0 waiting time 
            wt[0]=0;
        //calculate waiting time 
            for(i=1;i<n;i++)
        {
            wt[i]=0; for(j=0;j<i;j++) wt[i]+=bst[j]; total+=wt[i];
        }
        //Calculating Average waiting time 
        wait_avg=(float)total/n;
        total=0;
        System.out.println("-----------------------------------------------------------------------");
        System.out.println("\nProcess\t\t| Burst Time \t\t|Waiting Time\t\t|Turn Around Time");
        System.out.println("-----------------------------------------------------------------------");
        for(i=0;i<n;i++)
        {
            tat[i]=bst[i]+wt[i];
            total+=tat[i];//Calculating TurnaroundTimetotal+=tat[i];
            System.out.println("\np"+process[i]+"\t\t|\t"+bst[i]+"\t\t|\t"+wt[i]+"\t\t|\t"+tat[i]);
            System.out.println("-----------------------------------------------------------------------");
        }//Calculation of Average Turnaround Time
        TAT_avg=(float)total/n;
        System.out.println("\n\nAverage Waiting Time: "+wait_avg);
        System.out.println("\nAverage Turnaround Time: "+TAT_avg);
    }
}


###################################### SJF ##########################################################################
import java.util.Scanner;
class SJF{
    public static void main(String args[])
    { 
        int burst_time[],process[],waiting_time[],tat[],i,j,n,total=0,pp,temp; float wait_avg,TAT_avg; 
        Scanner s = new Scanner(System.in);
        System.out.print("Enter number of process: ");
        n = s.nextInt(); process = new int[n]; burst_time = new int[n]; waiting_time = new int[n]; 
        tat = new int[n]; 
        System.out.println("\nEnter Burst time:"); 
        for(i=0;i<n;i++) 
        { 
            System.out.print("\nProcess["+(i+1)+"]: "); burst_time[i] = s.nextInt();; 
            process[i]=i+1; //Process Number 
        } 
        System.out.println("\n \t \t*************** Shortest Job First Scheduling*********");
        //Sorting 
        for(i=0;i<n;i++) 
        { 
            pp=i; 
            for(j=i+1;j<n;j++) 
            { 
                if(burst_time[j]<burst_time[pp]) 
                pp=j; 
            }
            temp = burst_time[i]; 
            burst_time[i]=burst_time[pp]; 
            burst_time[pp]=temp; 
            temp=process[i]; 
            process[i]=process[pp]; 
            process[pp]=temp; 
        } 
        //First process has 0 waiting time 
        waiting_time[0]=0; 
        //calculate waiting time 
        for(i=1;i<n;i++) 
        { 
            waiting_time[i]=0; for(j=0;j<i;j++) waiting_time[i]+=burst_time[j]; 
            total+=waiting_time[i]; 
        } 
        //Calculating Average waiting time 
        wait_avg=(float)total/n; total=0; 
        System.out.println("----------------------------------------------------------"); 
        System.out.println("\nProcess\t| Burst Time \t|Waiting Time\t|Turnaround Time |"); 
        System.out.println("----------------------------------------------------------"); for(i=0;i<n;i++) 
        { 
            tat[i]=burst_time[i]+waiting_time[i]; 
            //Calculating Turnaround Time 
            total+=tat[i]; 
            System.out.println("\n p"+process[i]+"\t|\t "+burst_time[i]+"\t|\t "+waiting_time[i]+"\t|\t"+tat[i]+"\t|\t");
            System.out.println("----------------------------------------------------------"); 
        }
        //Calculation of Average Turnaround Time 
        TAT_avg=(float)total/n; 
        System.out.println("\n\nAverage Waiting Time: "+wait_avg); 
        System.out.println("\nAverage Turnaround Time: "+TAT_avg); 
    }
}

########################################## ROUND ROBIN ##################################################################
import java.util.Scanner;
public class RR{
    public static void main(String args[]) { Scanner s = new Scanner(System.in); 
    int wtime[],btime[],rtime[],num,quantum,total; 
    wtime = new int[10]; btime = new int[10]; rtime = new int[10]; 
    System.out.print("Enter number of processes(MAX 10): "); 
    num = s.nextInt(); 
    System.out.print("Enter burst time"); 
    for(int i=0;i<num;i++) 
{ 
    System.out.print("\nP["+(i+1)+"]: "); 
    btime[i] = s.nextInt();
    rtime[i] = btime[i]; 
    wtime[i]=0; 
} 
    System.out.print("\n\nEnter quantum: "); 
    quantum = s.nextInt(); int rp = num; 
    int i=0; int time=0; 
    System.out.print("0"); wtime[0]=0; 
    while(rp!=0) 
    { 
        if(rtime[i]>quantum) 
        { 
            rtime[i]=rtime[i]-quantum; 
            System.out.print(" | P["+(i+1)+"] | \n"); 
            time+=quantum; 
            System.out.print(time); 
        } 
        else if(rtime[i]<=quantum && rtime[i]>0)
        {
            time+=rtime[i]; 
            rtime[i]=rtime[i]-rtime[i]; 
            System.out.print(" | P["+(i+1)+"] | \n"); rp--; 
            System.out.print(time); 
        } 
        i++; if(i==num) 
        { i=0; } 
    } 
}
}
########################################## PRIORITY BASED ##############################################################
import java.util.Scanner; 
public class priority {
    public static void main(String args[]) 
    {
        Scanner s = new Scanner(System.in);
        int x,n,p[],pp[],bt[],w[],t[],awt,atat,i;
        p = new int[10]; pp = new int[10]; bt = new int[10]; w = new int[10]; t = new int[10]; 
        //n is number of process 
        //pp is process priority 
        //w is wait time 
        // t is turnaround time 
        //awt is average waiting time 
        //atat is average turnaround time 
        //p is process 
        //bt is process burst time 
        System.out.print("Enter the number of process : "); n = s.nextInt(); 
        System.out.print("\n\t Enter CPU time---priority \n"); for(i=0;i<n;i++)
        { 
            System.out.print("\nProcess["+(i+1)+"]:"); 
            bt[i] = s.nextInt(); pp[i] = s.nextInt(); p[i]=i+1; 
        }
        //sorting on the basis of priority for(i=0;i<n-1;i++)
        { 
            for(int j=i+1;j<n;j++) 
            {
                if(pp[i]<pp[j])
                {
                    x=pp[i]; pp[i]=pp[j]; pp[j]=x; x=bt[i]; bt[i]=bt[j]; bt[j]=x; x=p[i]; p[i]=p[j]; p[j]=x; 
                }
            } 
        } 
        w[0]=0; awt=0; t[0]=bt[0]; atat=t[0]; 
        for(i=1;i<n;i++)
        {
            w[i]=t[i-1]; awt+=w[i]; t[i]=w[i]+bt[i]; atat+=t[i];
        } 
        //Displaying the process 
        System.out.println("-----------------------------------------------------------------------");
        System.out.print("\n\nProcess \t |Burst Time \t |Wait Time \t |Turn Time \t |Process Priority \n");
        System.out.println("-----------------------------------------------------------------------");
        for(i=0;i<n;i++)
        System.out.print("\n"+p[i]+"\t\t| "+bt[i]+"\t\t| "+w[i]+"\t\t|"+t[i]+"\t\t| "+pp[i]+"\n"); 
        System.out.println("-----------------------------------------------------------------------"); 
        awt/=n; atat/=n;
        System.out.print("\n Average Wait Time : "+awt);
        System.out.print("\n Average Turn Around Time : "+atat);
    }
}



















































###################################FIRST FIT
// Java implementation of First - Fit algorithm
class firstFit
{
    // Method to allocate memory to
    // blocks as per First fit algorithm
    static void firstFit(int blockSize[], int m,
                         int processSize[], int n)
    {
        // Stores block id of the
        // block allocated to a process
        int allocation[] = new int[n];
     
        // Initially no block is assigned to any process
        for (int i = 0; i < allocation.length; i++)
            allocation[i] = -1;
     
        // pick each process and find suitable blocks
        // according to its size ad assign to it
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (blockSize[j] >= processSize[i])
                {
                    // allocate block j to p[i] process
                    allocation[i] = j;
     
                    // Reduce available memory in this block.
                    blockSize[j] -= processSize[i];
     
                    break;
                }
            }
        }
     
        System.out.println("\nProcess No.\tProcess Size\tBlock no.");
        for (int i = 0; i < n; i++)
        {
            System.out.print(" " + (i+1) + "\t\t" +
                             processSize[i] + "\t\t");
            if (allocation[i] != -1)
                System.out.print(allocation[i] + 1);
            else
                System.out.print("Not Allocated");
            System.out.println();
        }
    }
     
    // Driver Code
    public static void main(String[] args)
    {
        int blockSize[] = {200, 300, 200, 100, 400};
        int processSize[] = {112, 217, 312, 126};
        int m = blockSize.length;
        int n = processSize.length;
         
        firstFit(blockSize, m, processSize, n);
    }
}

############################### NEXT FIT

// Java program for next fit
// memory management algorithm
import java.util.Arrays;
 
public class nextFit {
 
// Function to allocate memory to blocks as per Next fit
// algorithm
    static void nextFit(int blockSize[], int m, int processSize[], int n) {
        // Stores block id of the block allocated to a
        // process
        int allocation[] = new int[n], j = 0;
 
        // Initially no block is assigned to any process
        Arrays.fill(allocation, -1);
 
        // pick each process and find suitable blocks
        // according to its size ad assign to it
        for (int i = 0; i < n; i++) {
 
            // Do not start from beginning
            int count =0;
            while (j < m) {
                count++;    //makes sure that for every process we traverse through entire array maximum once only.This avoids the problem of going into infinite loop if memory is not available
                if (blockSize[j] >= processSize[i]) {
 
                    // allocate block j to p[i] process
                    allocation[i] = j;
 
                    // Reduce available memory in this block.
                    blockSize[j] -= processSize[i];
 
                    break;
                }
 
                // mod m will help in traversing the blocks from
                // starting block after we reach the end.
                j = (j + 1) % m;
            }
        }
 
        System.out.print("\nProcess No.\tProcess Size\tBlock no.\n");
        for (int i = 0; i < n; i++) {
            System.out.print( i + 1 + "\t\t" + processSize[i]
                    + "\t\t");
            if (allocation[i] != -1) {
                System.out.print(allocation[i] + 1);
            } else {
                System.out.print("Not Allocated");
            }
            System.out.println("");
        }
    }
 
// Driver program
    static public void main(String[] args) {
        int blockSize[] = {5, 10, 25};
        int processSize[] = {10, 25, 5};
        int m = blockSize.length;
        int n = processSize.length;
        nextFit(blockSize, m, processSize, n);
    }
}
 
 
 #####################################BEST FIT
 // Java implementation of Best - Fit algorithm
  
public class bestFit
{
    // Method to allocate memory to blocks as per Best fit
    // algorithm
    static void bestFit(int blockSize[], int m, int processSize[], 
                                                     int n)
    {
        // Stores block id of the block allocated to a
        // process
        int allocation[] = new int[n];
       
        // Initially no block is assigned to any process
        for (int i = 0; i < allocation.length; i++)
            allocation[i] = -1;
       
     // pick each process and find suitable blocks
        // according to its size ad assign to it
        for (int i=0; i<n; i++)
        {
            // Find the best fit block for current process
            int bestIdx = -1;
            for (int j=0; j<m; j++)
            {
                if (blockSize[j] >= processSize[i])
                {
                    if (bestIdx == -1)
                        bestIdx = j;
                    else if (blockSize[bestIdx] > blockSize[j])
                        bestIdx = j;
                }
            }
       
            // If we could find a block for current process
            if (bestIdx != -1)
            {
                // allocate block j to p[i] process
                allocation[i] = bestIdx;
       
                // Reduce available memory in this block.
                blockSize[bestIdx] -= processSize[i];
            }
        }
       
        System.out.println("\nProcess No.\tProcess Size\tBlock no.");
        for (int i = 0; i < n; i++)
        {
            System.out.print("   " + (i+1) + "\t\t" + processSize[i] + "\t\t");
            if (allocation[i] != -1)
                System.out.print(allocation[i] + 1);
            else
                System.out.print("Not Allocated");
            System.out.println();
        }
    }
      
    // Driver Method
    public static void main(String[] args)
    {
         int blockSize[] = {200, 300, 200, 100, 400};
         int processSize[] = {112, 217, 312, 126};
         int m = blockSize.length;
         int n = processSize.length;
           
         bestFit(blockSize, m, processSize, n);
    }
}

#################################WORST FIT
// Java implementation of worst - Fit algorithm
 
public class worstFit
{
    // Method to allocate memory to blocks as per worst fit
    // algorithm
    static void worstFit(int blockSize[], int m, int processSize[],
                                                     int n)
    {
        // Stores block id of the block allocated to a
        // process
        int allocation[] = new int[n];
      
        // Initially no block is assigned to any process
        for (int i = 0; i < allocation.length; i++)
            allocation[i] = -1;
      
        // pick each process and find suitable blocks
        // according to its size ad assign to it
        for (int i=0; i<n; i++)
        {
            // Find the best fit block for current process
            int wstIdx = -1;
            for (int j=0; j<m; j++)
            {
                if (blockSize[j] >= processSize[i])
                {
                    if (wstIdx == -1)
                        wstIdx = j;
                    else if (blockSize[wstIdx] < blockSize[j])
                        wstIdx = j;
                }
            }
      
            // If we could find a block for current process
            if (wstIdx != -1)
            {
                // allocate block j to p[i] process
                allocation[i] = wstIdx;
      
                // Reduce available memory in this block.
                blockSize[wstIdx] -= processSize[i];
            }
        }
      
        System.out.println("\nProcess No.\tProcess Size\tBlock no.");
        for (int i = 0; i < n; i++)
        {
            System.out.print("   " + (i+1) + "\t\t" + processSize[i] + "\t\t");
            if (allocation[i] != -1)
                System.out.print(allocation[i] + 1);
            else
                System.out.print("Not Allocated");
            System.out.println();
        }
    }
     
    // Driver Method
    public static void main(String[] args)
    {
         int blockSize[] = {200, 300, 200, 100, 400};
         int processSize[] = {112, 217, 112, 426};
         int m = blockSize.length;
         int n = processSize.length;
          
         worstFit(blockSize, m, processSize, n);
    }
}





























PASS1
################################################ INPUT FILE ##############################################
####################################### CREATE INPUT FILE NAMED AS "in.txt" #############################
	START	100	
	READ	A	
LABEL	MOVER	A,B	
	LTORG
		='5'	
		='1'	
		='6'	
		='7'	
	MOVEM	A,B	
	LTORG	
		='2'	
LOOP	READ	B	
A	DS	1	
B	DC	'1'	
		='1'	
	END
################################################ CODE #####################################################
################################# create code file named "pass1.java" ####################################
import java.io.*;
class pass1
{
	public static void main(String args[])throws Exception
	{
		FileReader FP=new FileReader("in.txt");
		BufferedReader bufferedReader = new BufferedReader(FP);		
		
		String line=null;
		int line_count=0,LC=0,symTabLine=0,opTabLine=0,litTabLine=0,poolTabLine=0;
		  
		 //Data Structures
		 final int MAX=100;
		 String SymbolTab[][]=new String[MAX][3];
		 String OpTab[][]=new String[MAX][3];
		 String LitTab[][]=new String[MAX][2];
		 int PoolTab[]=new int[MAX];
		 int litTabAddress=0;
/*---------------------------------------------------------------------------------------------------*/
		 
		 System.out.println("___________________________________________________");
		    while((line = bufferedReader.readLine()) != null)
		     {
		     	 String[] tokens = line.split("\t");
		     	if(line_count==0)
		     	{
		     		LC=Integer.parseInt(tokens[2]);			//set LC to operand of START
		     		for(int i=0;i<tokens.length;i++)		//for printing the input program
		     	 		System.out.print(tokens[i]+"\t");
		     	 	System.out.println("");
		     	}
		     	else
		     	{
			     	 for(int i=0;i<tokens.length;i++) //for printing the input program
			     	 	System.out.print(tokens[i]+"\t");
			     	 System.out.println("");
			     	if(!tokens[0].equals(""))
			     	{
			 
			     		//Inserting into Symbol Table
			     		SymbolTab[symTabLine][0]=tokens[0];
			     		SymbolTab[symTabLine][1]=Integer.toString(LC);
			     		SymbolTab[symTabLine][2]=Integer.toString(1);
			     		symTabLine++;
			     	}
				else if(tokens[1].equalsIgnoreCase("DS")||tokens[1].equalsIgnoreCase("DC"))
				{
					//Entry into symbol table for declarative statements
					SymbolTab[symTabLine][0]=tokens[0];
			     		SymbolTab[symTabLine][1]=Integer.toString(LC);
			     		SymbolTab[symTabLine][2]=Integer.toString(1);
			     		symTabLine++;
				}

				if(tokens.length==3 && tokens[2].charAt(0)=='=')
				{
					//Entry of literals into literal table
					LitTab[litTabLine][0]=tokens[2];
			     		LitTab[litTabLine][1]=Integer.toString(LC);
			     		litTabLine++;
				}
	
				else if(tokens[1]!=null)
				{
						//Entry of Mnemonic in opcode table
					OpTab[opTabLine][0]=tokens[1];
					
					if(tokens[1].equalsIgnoreCase("START")||tokens[1].equalsIgnoreCase("END")||tokens[1].equalsIgnoreCase("ORIGIN")||tokens[1].equalsIgnoreCase("EQU")||tokens[1].equalsIgnoreCase("LTORG"))		//if Assembler Directive
					{
			     			OpTab[opTabLine][1]="AD";
						OpTab[opTabLine][2]="R11";					
					}			     	
					else if(tokens[1].equalsIgnoreCase("DS")||tokens[1].equalsIgnoreCase("DC"))
					{
						OpTab[opTabLine][1]="DL";
						OpTab[opTabLine][2]="R7";					
					}
					else
					{
						OpTab[opTabLine][1]="IS";
						OpTab[opTabLine][2]="(04,1)";
					}
			     	opTabLine++;
				}
		        }
		        line_count++;
		        LC++;
		    }   

			System.out.println("___________________________________________________");  

			//print symbol table
			System.out.println("\n\n	SYMBOL TABLE		");
			System.out.println("--------------------------");			
			System.out.println("SYMBOL\tADDRESS\tLENGTH");
			System.out.println("--------------------------");			
			for(int i=0;i<symTabLine;i++)
				System.out.println(SymbolTab[i][0]+"\t"+SymbolTab[i][1]+"\t"+SymbolTab[i][2]);
			System.out.println("--------------------------");


			//print opcode table
			System.out.println("\n\n	OPCODE TABLE		");
			System.out.println("----------------------------");			
			System.out.println("MNEMONIC\tCLASS\tINFO");
			System.out.println("----------------------------");			
			for(int i=0;i<opTabLine;i++)
				System.out.println(OpTab[i][0]+"\t\t"+OpTab[i][1]+"\t"+OpTab[i][2]);
			System.out.println("----------------------------");

			//print literal table
			System.out.println("\n\n   LITERAL TABLE		");
			System.out.println("-----------------");			
			System.out.println("LITERAL\tADDRESS");
			System.out.println("-----------------");			
			for(int i=0;i<litTabLine;i++)
				System.out.println(LitTab[i][0]+"\t"+LitTab[i][1]);
			System.out.println("------------------");
	

			//intialization of POOLTAB
			for(int i=0;i<litTabLine;i++)
			{
				if(LitTab[i][0]!=null && LitTab[i+1][0]!=null ) //if literals are present
				{
					if(i==0)
					{
						PoolTab[poolTabLine]=i+1;
						poolTabLine++;
					}
					else if(Integer.parseInt(LitTab[i][1])<(Integer.parseInt(LitTab[i+1][1]))-1)
					{	
						PoolTab[poolTabLine]=i+2;
						poolTabLine++;
					}
				}
			}
			//print pool table
			System.out.println("\n\n   POOL TABLE		");
			System.out.println("-----------------");			
			System.out.println("LITERAL NUMBER");
			System.out.println("-----------------");			
			for(int i=0;i<poolTabLine;i++)
				System.out.println(PoolTab[i]);
			System.out.println("------------------");
			
		
		    // Always close files.
		    bufferedReader.close();
	}
}


























PASS 2
#################################### INTERMEDIATE FILE #################################################
###################################### create intermediate file named "intermediate.txt"  ##########################  
(AD,01)(C,200)
(IS,04)(1)(L,1)
(IS,05)(1)(S,1)
(IS,04)(1)(S,1)
(IS,04)(3)(S,3)
(IS,01)(3)(L,2)
(IS,07)(6)(S,4)
(DL,01)(C,5)
(DL,01)(C,1)
(IS,02)(1)(L,3)
(IS,07)(1)(S,5)
(IS,00)
(AD,03)(S,2)+2
(IS,03)(3)(S,3)
(AD,03)(S,6)+1
(DL,02)(C,1)
(DL,02)(C,1)
(AD,02)
(DL,01)(C,1)

############################ SYMTAB FILE ###################################################################
###################################### create symtab file named "symtab.txt" ##########################  
A   211   1
LOOP    202   1
B   212   1
NEXT    208   1
BACK    202   1
LAST    210   1

############################ LITTAB FILE ###################################################################
###################################### create littab file named "littab.txt" ##########################  
5		206
1		207
1		213

################################## CODE ###################################################################
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.HashMap;

public class Pass2 {
	public static void main(String[] Args) throws IOException{
		 BufferedReader b1 = new BufferedReader(new FileReader("intermediate.txt"));
	     BufferedReader b2 = new BufferedReader(new FileReader("symtab.txt"));
	     BufferedReader b3 = new BufferedReader(new FileReader("littab.txt"));
	     FileWriter f1 = new FileWriter("Pass2.txt");
	     HashMap<Integer, String> symSymbol = new HashMap<Integer, String>();
	     HashMap<Integer, String> litSymbol = new HashMap<Integer, String>();
	     HashMap<Integer, String> litAddr = new HashMap<Integer, String>();
	     String s;
	     int symtabPointer=1,littabPointer=1,offset;
	     while((s=b2.readLine())!=null){
	    	 String word[]=s.split("\t\t\t");
	    	 symSymbol.put(symtabPointer++,word[1]);
	     }
	     while((s=b3.readLine())!=null){
	    	 String word[]=s.split("\t\t");
	    	 litSymbol.put(littabPointer,word[0]);
	    	 litAddr.put(littabPointer++,word[1]);
	     }
	     while((s=b1.readLine())!=null){
	    	 if(s.substring(1,6).compareToIgnoreCase("IS,00")==0){
	    		 f1.write("+ 00 0 000\n");
	    	 }
	    	 else if(s.substring(1,3).compareToIgnoreCase("IS")==0){
	    		 f1.write("+ "+s.substring(4,6)+" ");
	    		 if(s.charAt(9)==')'){
	    			 f1.write(s.charAt(8)+" ");
	    			 offset=3;
	    		 }
	    		 else{
	    			 f1.write("0 ");
	    			 offset=0;
	    		 }
	    		 if(s.charAt(8+offset)=='S')
    				 f1.write(symSymbol.get(Integer.parseInt(s.substring(10+offset,s.length()-1)))+"\n");
    			 else
    	 			 f1.write(litAddr.get(Integer.parseInt(s.substring(10+offset,s.length()-1)))+"\n");
    	   	} 
	    	 else if(s.substring(1,6).compareToIgnoreCase("DL,01")==0){
	    		 String s1=s.substring(10,s.length()-1),s2="";
	    		 for(int i=0;i<3-s1.length();i++)
	    			 s2+="0";
	    		 s2+=s1;
	    		 f1.write("+ 00 0 "+s2+"\n");
	    	 }
	    	 else{
	    		 f1.write("\n");
	    	 }
	     }
	     f1.close();
	     b1.close();
	     b2.close();
	     b3.close();
	}
}





































GUI

from tkinter import *
import tkinter as tk
from tkinter import Entry,Tk
from PIL import Image
from PIL import ImageTk
from tkinter import ttk
root=Tk()




def confirm():
	newWindow = Toplevel(root)

	# sets the title of the
	newWindow.title("Confirmation")

	newWindow.geometry("300x300")
	
	
     
	label1=Label(newWindow,text="Your Payment Has Been Done Successfully.").place(x=10,y=70)
	label2=Label(newWindow,text="We Have Also Sent The Booking Details On Your").place(x=10,y=90)
	label3=Label(newWindow,text="Registered Mobile Number.").place(x=10,y=110)
	label4=Label(newWindow,text="Thank You for using MSRTC app for booking your ticket.").place(x=10,y=130)

def payment():
	newWindow = Toplevel(root)
	newWindow.title("Payments")


	newWindow.geometry("300x580")
	newWindow.minsize(300,580)
	newWindow.maxsize(300,580)
	newWindow.configure(bg='white')
	image = Image.open("title.png")

	
	# Resize the image using resize() method
	resize_image = image.resize((300, 15))
	
	img = ImageTk.PhotoImage(resize_image)

	label1 = Label(newWindow,image=img,bg='white')
	label1.image =img
	label1.place(x=0,y=0)
	image = Image.open("screen.png")


	resize_image = image.resize((300, 50))
	
	img = ImageTk.PhotoImage(resize_image)

	label1 = Label(newWindow,image=img,bg='white')
	label1.image =img
	label1.place(x=0,y=10)
	image=Image.open("map3.png")
	resize_image =image.resize((20, 20))
	img = ImageTk.PhotoImage(resize_image)
	button= Button(newWindow, image=img,borderwidth=0)
	button.image=img
	button.place(x=262,y=15)
	image=Image.open("arrow.png") 
	resize_image =image.resize((20, 20))
	img = ImageTk.PhotoImage(resize_image)
	button= Button(newWindow, image=img,borderwidth=0)
	button.image=img
	button.place(x=5,y=15)


	label2=Label(newWindow, text="Payments",bg="white", font="arial 13 bold").place(x=100, y=72)


	b = Button(newWindow, bg='white',height=8,width=50,borderwidth=0).place(x=0,y=100) 
	separator = ttk.Separator(newWindow, orient='horizontal')
	separator.place(relx=0, rely=0.26, relwidth=1, relheight=1)
	Label(newWindow,text="PhonePe, Google pay(UPI Wallet)",font="arial 9 bold",bg="white").place(x=55,y=110)
	image = Image.open("UPI-Logo.png")
	resize_image = image.resize((40, 40))
	img1 = ImageTk.PhotoImage(resize_image)
	label1 = Label(newWindow,image=img1,bg='white')
	label1.image =img1
	label1.place(x=10,y=100)



	b = Button(newWindow, bg='white',height=8,width=50,borderwidth=0).place(x=0,y=153)  
	separator = ttk.Separator(newWindow, orient='horizontal')
	separator.place(relx=0, rely=0.35, relwidth=1, relheight=1)
	label2=Label(newWindow,text="Credit Card, Debit Card",font="arial 9 bold",bg="white").place(x=55,y=168)
	image = Image.open("credit.png")
	resize_image = image.resize((40, 40))
	img2 = ImageTk.PhotoImage(resize_image)
	label1 = Label(newWindow,image=img2,bg='white')
	label1.image =img2
	label1.place(x=10,y=155)


	b = Button(newWindow, bg='white',height=8,width=50,borderwidth=0).place(x=0,y=204)  
	separator = ttk.Separator(newWindow, orient='horizontal')
	separator.place(relx=0, rely=0.45, relwidth=1, relheight=1)
	label3=Label(newWindow,text="Net Banking",font="arial 9 bold",bg="white").place(x=55,y=225)
	image = Image.open("netb.png")
	resize_image = image.resize((40, 40))
	img3 = ImageTk.PhotoImage(resize_image)
	label1 = Label(newWindow,image=img3,bg='white')
	label1.image =img3
	label1.place(x=10,y=210)



	image = Image.open("QRimg.png")
	resize_image = image.resize((120, 120))
	img4 = ImageTk.PhotoImage(resize_image)
	label1 = Label(newWindow,image=img4,bg='white')
	label1.image =img4
	label1.place(x=90,y=280)
	



	label1=Label(newWindow,text="OR",font="arial 9").place(x=140,y=410)

	label2=Label(newWindow,text="Enter Your UPI ID",font="arial 9 bold").place(x=55,y=430)
	upi_id=tk.StringVar()
	upi_id=Entry(newWindow,width=30,textvariable=upi_id).place(x=55,y=450)

	b = Button(newWindow, text="Make Payment", bg='orange',command=confirm,height=2,width=20,borderwidth=0).place(x=80,y=480)  


root.geometry("300x580")
root.minsize(300,580)
root.maxsize(300,580)
root.configure(bg='white')
image = Image.open("title.png")

 
# Resize the image using resize() method
resize_image = image.resize((300, 15))
 
img = ImageTk.PhotoImage(resize_image)

label1 = Label(image=img,bg='white')
label1.image =img
label1.place(x=0,y=0)
image = Image.open("screen.png")


resize_image = image.resize((300, 50))
 
img = ImageTk.PhotoImage(resize_image)

label1 = Label(image=img,bg='white')
label1.image =img
label1.place(x=0,y=10)
image=Image.open("map3.png")
resize_image =image.resize((20, 20))
img = ImageTk.PhotoImage(resize_image)
button= Button(root, image=img,borderwidth=0)
button.image=img
button.place(x=262,y=15)
image=Image.open("arrow.png") 
resize_image =image.resize((20, 20))
img = ImageTk.PhotoImage(resize_image)
button= Button(root, image=img,borderwidth=0)
button.image=img
button.place(x=5,y=15)
label2=Label(root,text="Confirmation",bg='white', font="arial 13 bold").place(x=100,y=72)

frame1=Frame(root, bg='#C0C0C0',height=70 ,width=300).place(x=0,y=100)
label1_frame1=Label(frame1,text="Route: CHINCHWAD to PANDHARPUR via",font="arial 9",bg="#C0C0C0").place(x=15,y=105)
label2_frame1=Label(frame1, text="Swargate, Pune(31/08/2022 14:30:00)",font="arial 9",bg="#C0C0C0").place(x=55,y=120)
label3_frame1=Label(frame1, text="Bus Type: ORDINARY EXPRESS",font="arial 9",bg="#C0C0C0").place(x=15,y=140)


frame2=Frame(root, bg='#C0C0C0',height=80 ,width=300).place(x=0,y=180)
label1_frame2=Label(frame2,text="Boarding Stop: SWARGATE, PUNE(15:00)",font="arial 9",bg="#C0C0C0").place(x=15,y=185)
label2_frame2=Label(frame2, text="Alighting Stop: PANDHARPUR(20:30)",font="arial 9",bg="#C0C0C0").place(x=15,y=203)
label3_frame2=Label(frame2, text="Total Seats: 1",font="arial 9",bg="#C0C0C0").place(x=15,y=221)
label3_frame2=Label(frame2, text="Seat Number: 5",font="arial 9",bg="#C0C0C0").place(x=15,y=236)


frame3=Frame(root, bg='#C0C0C0',height=30 ,width=300).place(x=0,y=275)
label1_frame3=Label(frame3,text="Contact Details",font="arial 9",bg="#C0C0C0").place(x=15,y=280)


frame4=Frame(root, bg='#666666',height=30 ,width=300, border=1).place(x=0,y=300)
label1_frame4=Label(frame4,text="Mobile Number: +91-9865432121",font="arial 9",bg="#666666").place(x=15,y=305)


frame5=Frame(root, bg='#C0C0C0',height=100 ,width=300).place(x=0,y=345)
label1_frame5=Label(frame5,text="Passenger Details",font="arial 9",bg="#C0C0C0").place(x=15,y=350)


frame6=Frame(root, bg='#666666',height=80 ,width=300).place(x=0,y=370)
label1_frame6=Label(frame6,text="Name: Dipesh Toke",font="arial 9",bg="#666666").place(x=15,y=375)
label1_frame6=Label(frame6,text="Age: 20",font="arial 9",bg="#666666").place(x=15,y=395)
label1_frame6=Label(frame6,text="Gender Male",font="arial 9",bg="#666666").place(x=15,y=415)


b = Button(root, text="Pay / ??? ???", bg='orange',command=payment,height=2,width=20,borderwidth=0).place(x=80,y=480)  


root.mainloop()
